{"ast":null,"code":"'use strict';\n\nvar path = require('path');\n\nvar fs = require('fs');\n\nvar glob = require('glob');\n\nvar mkdirp = require('mkdirp');\n\nvar untildify = require('untildify');\n\nvar through = require('through2').obj;\n\nvar noms = require('noms').obj;\n\nfunction toStream(array) {\n  var length = array.length;\n  var i = 0;\n  return noms(function (done) {\n    if (i >= length) {\n      this.push(null);\n    }\n\n    this.push(array[i++]);\n    done();\n  });\n}\n\nfunction depth(string) {\n  return path.normalize(string).split(path.sep).length - 1;\n}\n\nfunction dealWith(inPath, up) {\n  if (!up) {\n    return inPath;\n  }\n\n  if (up === true) {\n    return path.basename(inPath);\n  }\n\n  if (depth(inPath) < up) {\n    throw new Error('cant go up that far');\n  }\n\n  return path.join.apply(path, path.normalize(inPath).split(path.sep).slice(up));\n}\n\nvar copyFile = _copyFile;\n\nfunction _copyFile(src, dst, opts, callback) {\n  fs.createReadStream(src).pipe(fs.createWriteStream(dst, {\n    mode: opts.mode\n  })).once('error', callback).once('finish', function () {\n    fs.chmod(dst, opts.mode, function (err) {\n      callback(err);\n    });\n  });\n}\n\nif (fs.copyFile) {\n  copyFile = function (src, dst, opts, callback) {\n    fs.copyFile(src, dst, callback);\n  };\n}\n\nfunction makeDebug(config) {\n  if (config.verbose) {\n    return function (thing) {\n      console.log(thing);\n    };\n  }\n\n  return function () {};\n}\n\nmodule.exports = copyFiles;\n\nfunction copyFiles(args, config, callback) {\n  if (typeof config === 'function') {\n    callback = config;\n    config = {\n      up: 0\n    };\n  }\n\n  if (typeof config !== 'object' && config) {\n    config = {\n      up: config\n    };\n  }\n\n  var debug = makeDebug(config);\n  var copied = false;\n  var opts = config.up || 0;\n  var soft = config.soft;\n\n  if (typeof callback !== 'function') {\n    throw new Error('callback is not optional');\n  }\n\n  var input = args.slice();\n  var outDir = input.pop();\n  var globOpts = {};\n\n  if (config.exclude) {\n    globOpts.ignore = config.exclude;\n  }\n\n  if (config.all) {\n    globOpts.dot = true;\n  }\n\n  if (config.follow) {\n    globOpts.follow = true;\n  }\n\n  outDir = outDir.startsWith('~') ? untildify(outDir) : outDir;\n  toStream(input.map(function (srcP) {\n    return srcP.startsWith('~') ? untildify(srcP) : srcP;\n  })).pipe(through(function (pathName, _, next) {\n    var self = this;\n    glob(pathName, globOpts, function (err, paths) {\n      if (err) {\n        return next(err);\n      }\n\n      paths.forEach(function (unglobbedPath) {\n        debug(`unglobed path: ${unglobbedPath}`);\n        self.push(unglobbedPath);\n      });\n      next();\n    });\n  })).on('error', callback).pipe(through(function (pathName, _, next) {\n    fs.stat(pathName, function (err, pathStat) {\n      if (err) {\n        return next(err);\n      }\n\n      var outName = path.join(outDir, dealWith(pathName, opts));\n\n      function done() {\n        mkdirp(path.dirname(outName)).then(() => {\n          next(null, {\n            pathName: pathName,\n            pathStat: pathStat\n          });\n        }, next);\n      }\n\n      if (pathStat.isDirectory()) {\n        debug(`skipping, is directory: ${pathName}`);\n        return next();\n      }\n\n      if (!pathStat.isFile()) {\n        return next(new Error('how can it be neither file nor folder?'));\n      }\n\n      if (!soft) {\n        return done();\n      }\n\n      fs.stat(outName, function (err) {\n        if (!err) {\n          //file exists\n          return next();\n        }\n\n        if (err.code === 'ENOENT') {\n          //file does not exist\n          return done();\n        } // other error\n\n\n        return next(err);\n      });\n    });\n  })).on('error', callback).pipe(through(function (obj, _, next) {\n    if (!copied) {\n      copied = true;\n    }\n\n    var pathName = obj.pathName;\n    var pathStat = obj.pathStat;\n    var outName = path.join(outDir, dealWith(pathName, opts));\n    debug(`copy from: ${pathName}`);\n    debug(`copy to: ${outName}`);\n    copyFile(pathName, outName, pathStat, next);\n  })).on('error', callback).on('finish', function () {\n    if (config.error && !copied) {\n      return callback(new Error('nothing coppied'));\n    }\n\n    callback();\n  });\n}","map":{"version":3,"sources":["C:/Users/joshc/node_modules/copyfiles/index.js"],"names":["path","require","fs","glob","mkdirp","untildify","through","obj","noms","toStream","array","length","i","done","push","depth","string","normalize","split","sep","dealWith","inPath","up","basename","Error","join","apply","slice","copyFile","_copyFile","src","dst","opts","callback","createReadStream","pipe","createWriteStream","mode","once","chmod","err","makeDebug","config","verbose","thing","console","log","module","exports","copyFiles","args","debug","copied","soft","input","outDir","pop","globOpts","exclude","ignore","all","dot","follow","startsWith","map","srcP","pathName","_","next","self","paths","forEach","unglobbedPath","on","stat","pathStat","outName","dirname","then","isDirectory","isFile","code","error"],"mappings":"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","sourcesContent":["'use strict';\nvar path = require('path');\nvar fs = require('fs');\nvar glob = require('glob');\nvar mkdirp = require('mkdirp');\nvar untildify = require('untildify');\nvar through = require('through2').obj;\nvar noms = require('noms').obj;\nfunction toStream(array) {\n  var length = array.length;\n  var i = 0;\n  return noms(function (done) {\n    if (i >= length) {\n      this.push(null);\n    }\n    this.push(array[i++]);\n    done();\n  });\n}\nfunction depth(string) {\n  return path.normalize(string).split(path.sep).length - 1;\n}\nfunction dealWith(inPath, up) {\n  if (!up) {\n    return inPath;\n  }\n  if (up === true) {\n    return path.basename(inPath);\n  }\n  if (depth(inPath) < up) {\n    throw new Error('cant go up that far');\n  }\n  return path.join.apply(path, path.normalize(inPath).split(path.sep).slice(up));\n}\nvar copyFile = _copyFile;\nfunction _copyFile (src, dst, opts, callback) {\n  fs.createReadStream(src)\n    .pipe(fs.createWriteStream(dst, {\n      mode: opts.mode\n    }))\n    .once('error', callback)\n    .once('finish', function () {\n      fs.chmod(dst, opts.mode, function (err) {\n        callback(err);\n      })\n    })\n}\nif (fs.copyFile) {\n  copyFile = function (src, dst, opts, callback) {\n    fs.copyFile(src, dst, callback);\n  }\n}\nfunction makeDebug(config) {\n  if (config.verbose) {\n    return function (thing) {\n      console.log(thing);\n    }\n  }\n  return function () {}\n}\nmodule.exports = copyFiles;\nfunction copyFiles(args, config, callback) {\n  if (typeof config === 'function') {\n    callback = config;\n    config = {\n      up:0\n    };\n  }\n  if (typeof config !== 'object' && config) {\n    config = {\n      up: config\n    };\n  }\n  var debug = makeDebug(config);\n  var copied = false;\n  var opts = config.up || 0;\n  var soft = config.soft;\n  if (typeof callback !== 'function') {\n    throw new Error('callback is not optional');\n  }\n  var input = args.slice();\n  var outDir = input.pop();\n  var globOpts = {};\n  if (config.exclude) {\n    globOpts.ignore = config.exclude;\n  }\n  if (config.all) {\n    globOpts.dot = true;\n  }\n  if (config.follow) {\n    globOpts.follow = true;\n  }\n  outDir = outDir.startsWith('~') ? untildify(outDir) : outDir;\n  toStream(input.map(function(srcP) {return srcP.startsWith('~') ? untildify(srcP) : srcP;}))\n  .pipe(through(function (pathName, _, next) {\n    var self = this;\n    glob(pathName, globOpts, function (err, paths) {\n      if (err) {\n        return next(err);\n      }\n      paths.forEach(function (unglobbedPath) {\n        debug(`unglobed path: ${unglobbedPath}`);\n        self.push(unglobbedPath);\n      });\n      next();\n    });\n  }))\n  .on('error', callback)\n  .pipe(through(function (pathName, _, next) {\n    fs.stat(pathName, function (err, pathStat) {\n      if (err) {\n        return next(err);\n      }\n      var outName = path.join(outDir, dealWith(pathName, opts));\n      function done(){\n        mkdirp(path.dirname(outName)).then(()=>{\n          next(null, {\n            pathName: pathName,\n            pathStat: pathStat\n          });\n        }, next);\n      }\n      if (pathStat.isDirectory()) {\n        debug(`skipping, is directory: ${pathName}`)\n        return next();\n      }\n      if (!pathStat.isFile()) {\n        return next(new Error('how can it be neither file nor folder?'))\n      }\n      if (!soft) {\n        return done();\n      }\n      fs.stat(outName, function(err){\n        if(!err){\n          //file exists\n          return next()\n        }\n        if (err.code === 'ENOENT') {\n          //file does not exist\n          return done();\n        }\n        // other error\n        return next(err)\n      })\n    });\n  }))\n  .on('error', callback)\n  .pipe(through(function (obj, _, next) {\n\n    if (!copied) {\n      copied = true;\n    }\n    var pathName = obj.pathName;\n    var pathStat = obj.pathStat;\n    var outName = path.join(outDir, dealWith(pathName, opts));\n    debug(`copy from: ${pathName}`)\n    debug(`copy to: ${outName}`)\n    copyFile(pathName, outName, pathStat, next)\n  }))\n  .on('error', callback)\n  .on('finish', function () {\n    if (config.error && !copied) {\n      return callback(new Error('nothing coppied'));\n    }\n    callback();\n  });\n}\n"]},"metadata":{},"sourceType":"script"}